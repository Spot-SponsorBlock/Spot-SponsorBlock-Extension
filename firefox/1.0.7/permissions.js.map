{"version":3,"file":"permissions.js","mappings":"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","sources":["webpack:///./src/background-request-proxy.ts","webpack:///./src/config.ts","webpack:///./src/config/config.ts","webpack:///./src/permissions.ts","webpack:///./src/types.ts","webpack:///./src/utils.ts","webpack:///./src/utils/dom.ts","webpack:///./src/utils/formating.ts","webpack:///./src/utils/hash.ts","webpack:///./src/utils/index.ts","webpack:///./src/utils/requests.ts","webpack:///./src/utils/setup.ts","webpack:///./src/utils/skipRule.type.ts","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"sourcesContent":["import { isFirefoxOrSafari, objectToURI } from \"./utils/index\";\nimport { isSafari } from \"./config/config\";\nimport { isBodyGarbage } from \"./utils/formating\";\nimport { getHash } from \"./utils/hash\";\n\nexport interface FetchResponse {\n    responseText: string;\n    headers: Record<string, string> | null;\n    status: number;\n    ok: boolean;\n}\n\nexport interface FetchResponseBinary {\n    responseBinary: Blob | number[];\n    headers: Record<string, string> | null;\n    status: number;\n    ok: boolean;\n}\n\n/**\n * Sends a request to the specified url\n *\n * @param type The request type \"GET\", \"POST\", etc.\n * @param address The address to add to the SponsorBlock server address\n * @param callback\n */\nexport async function sendRealRequestToCustomServer(type: string, url: string,\n        data: Record<string, unknown> | null = {}, headers: Record<string, unknown> = {}) {\n    // If GET, convert JSON to parameters\n    if (type.toLowerCase() === \"get\") {\n        url = objectToURI(url, data, true);\n\n        data = null;\n    }\n\n    const response = await fetch(url, {\n        method: type,\n        headers: {\n            'Content-Type': 'application/json',\n            ...(headers || {})\n        },\n        redirect: 'follow',\n        body: data ? JSON.stringify(data) : null\n    });\n\n    return response;\n}\n\n/**\n * Checks whether the value is safe to send using .postMessage()\n *\n * @param value The value to check\n * @returns true if the value is serializable, false otherwise\n */\nexport function isSerializable(value: unknown): boolean {\n    try {\n        window.structuredClone(value);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\ninterface MaybeError {\n    toString?: () => string,\n}\n\n/**\n * Ensures the value is serializable by converting to a string if it's not\n *\n * Useful for sending errors cause you never really know what \"error\" you may get with JS\n *\n * @param value The value to check\n * @returns Unmodified value if serializable, stringified version otherwise\n */\nexport function serializeOrStringify<T>(value: T & MaybeError): T | string {\n    return isSerializable(value)\n        ? value\n        : (\n            \"toString\" in value && typeof value.toString === 'function'\n            ? value.toString()\n            : String(value)\n        );\n}\n\nexport function setupBackgroundRequestProxy() {\n    chrome.runtime.onMessage.addListener((request, sender, callback) => {\n        if (request.message === \"sendRequest\") {\n            sendRealRequestToCustomServer(request.type, request.url, request.data, request.headers).then(async (response) => {\n                const buffer = request.binary \n                    ? ((isFirefoxOrSafari() && !isSafari())\n                        ? await response.blob()\n                        : Array.from(new Uint8Array(await response.arrayBuffer())))\n                    : null;\n\n                callback({\n                    responseText: !request.binary ? await response.text() : \"\",\n                    responseBinary: buffer,\n                    headers: (request.returnHeaders && response.headers)\n                            ? [...response.headers.entries()].reduce((acc, [key, value]) => {\n                                acc[key] = value;\n                                return acc;\n                            }\n                        , {})\n                        : null,\n                    status: response.status,\n                    ok: response.ok\n                });\n            }).catch(error => {\n                console.error(\"Proxied request failed:\", error)\n                callback({\n                    error: serializeOrStringify(error),\n                });\n            });\n\n            return true;\n        }\n\n        if (request.message === \"getHash\") {\n            getHash(request.value, request.times).then(callback).catch((e) => {\n                console.error(\"Hash request failed:\", e)\n                callback({\n                    error: serializeOrStringify(e),\n                });\n            });\n\n            return true;\n        }\n\n        return false;\n    });\n}\n\nexport function sendRequestToCustomServer(type: string, url: string, data = {}, headers = {}): Promise<FetchResponse> {\n    return new Promise((resolve, reject) => {\n        // Ask the background script to do the work\n        chrome.runtime.sendMessage({\n            message: \"sendRequest\",\n            type,\n            url,\n            data,\n            headers\n        }, (response) => {\n            if (\"error\" in response) {\n                reject(response.error);\n            } else {\n                resolve(response);\n            }\n        });\n    });\n}\n\nexport function sendBinaryRequestToCustomServer(type: string, url: string, data = {}, headers = {}): Promise<FetchResponseBinary> {\n    return new Promise((resolve, reject) => {\n        // Ask the background script to do the work\n        chrome.runtime.sendMessage({\n            message: \"sendRequest\",\n            type,\n            url,\n            data,\n            headers,\n            binary: true,\n            returnHeaders: true\n        }, (response) => {\n            if (\"error\" in response) {\n                reject(response.error);\n            } else {\n                resolve(response);\n            }\n        });\n    });\n}\n\n/**\n * Formats and `console.warn`s the given request\n *\n * Use this to log failed requests.\n *\n * @param request The request to log\n * @param prefix Extension prefix, such as \"SB\" or \"CB\". Brackets will be added automatically\n * @param requestDescription A string describing what the failed request was, such as \"segment skip log\", which would produce \"Server responded ... to a segment skip log request\"\n */\nexport function logRequest(request: FetchResponse | FetchResponseBinary, prefix: string, requestDescription: string) {\n    const body = (\"responseText\" in request && !isBodyGarbage(request.responseText)) ? `: ${request.responseText}` : \"\"\n    console.warn(`[${prefix}] Server responded with code ${request.status} to a ${requestDescription} request${body}`);\n}\n","import * as CompileConfig from \"../config.json\";\nimport { Category, CategorySelection, CategorySkipOption, NoticeVisibilityMode, PreviewBarOption, SponsorHideType, SponsorTime, VideoID, SegmentListDefaultTab } from \"./types\";\nimport { Keybind, keybindEquals, ProtoConfig } from \"./config/config\";\nimport { HashedValue } from \"./utils/hash\";\nimport { AdvancedSkipCheck, AdvancedSkipPredicate, AdvancedSkipRule, Permission, PredicateOperator } from \"./utils/skipRule.type\";\n\ninterface SBConfig {\n    userID: string;\n    isVip: boolean;\n    permissions: Record<Category, Permission>;\n    defaultCategory: Category;\n    segmentListDefaultTab: SegmentListDefaultTab;\n    renderSegmentsAsChapters: boolean;\n    forceChannelCheck: boolean;\n    minutesSaved: number;\n    skipCount: number;\n    sponsorTimesContributed: number;\n    submissionCountSinceCategories: number; // New count used to show the \"Read The Guidelines!!\" message\n    showTimeWithSkips: boolean;\n    disableSkipping: boolean;\n    fullVideoSegments: boolean;\n    fullVideoLabelsOnThumbnails: boolean;\n    manualSkipOnFullVideo: boolean;\n    trackViewCount: boolean;\n    trackViewCountInPrivate: boolean;\n    trackDownvotes: boolean;\n    trackDownvotesInPrivate: boolean;\n    dontShowNotice: boolean;\n    showUpcomingNotice: boolean;\n    noticeVisibilityMode: NoticeVisibilityMode;\n    hideVideoPlayerControls: boolean;\n    hideInfoButtonPlayerControls: boolean;\n    hideDeleteButtonPlayerControls: boolean;\n    hideUploadButtonPlayerControls: boolean;\n    hideSkipButtonPlayerControls: boolean;\n    hideDiscordLaunches: number;\n    hideDiscordLink: boolean;\n    serverAddress: string;\n    minDuration: number;\n    skipNoticeDuration: number;\n    audioNotificationOnSkip: boolean;\n    testingServer: boolean;\n    allowExpirements: boolean;\n    showDonationLink: boolean;\n    showPopupDonationCount: number;\n    showUpsells: boolean;\n    showNewFeaturePopups: boolean;\n    donateClicked: number;\n    autoHideInfoButton: boolean;\n    colorPalette: {\n        red: string;\n        white: string;\n        locked: string;\n    };\n    scrollToEditTimeUpdate: boolean;\n    categoryPillUpdate: boolean;\n    hookUpdate: boolean;\n    showChapterInfoMessage: boolean;\n    darkMode: boolean;\n    showCategoryGuidelines: boolean;\n    showCategoryWithoutPermission: boolean;\n    showSegmentNameInChapterBar: boolean;\n    useVirtualTime: boolean;\n    showSegmentFailedToFetchWarning: boolean;\n    allowScrollingToEdit: boolean;\n    showZoomToFillError2: boolean;\n    cleanPopup: boolean;\n    hideSegmentCreationInPopup: boolean;\n    prideTheme: boolean;\n\n    // Used to cache calculated text color info\n    categoryPillColors: {\n        [key in Category]: {\n            lastColor: string;\n            textColor: string;\n        }\n    };\n\n    skipKeybind: Keybind;\n    skipToHighlightKeybind: Keybind;\n    startSponsorKeybind: Keybind;\n    submitKeybind: Keybind;\n    actuallySubmitKeybind: Keybind;\n    previewKeybind: Keybind;\n    nextChapterKeybind: Keybind;\n    previousChapterKeybind: Keybind;\n    closeSkipNoticeKeybind: Keybind;\n    upvoteKeybind: Keybind;\n    downvoteKeybind: Keybind;\n\n    // What categories should be skipped\n    categorySelections: CategorySelection[];\n\n    // Preview bar\n    barTypes: {\n        \"preview-chooseACategory\": PreviewBarOption;\n        \"sponsor\": PreviewBarOption;\n        \"preview-sponsor\": PreviewBarOption;\n        \"selfpromo\": PreviewBarOption;\n        \"preview-selfpromo\": PreviewBarOption;\n        \"exclusive_access\": PreviewBarOption;\n        \"interaction\": PreviewBarOption;\n        \"preview-interaction\": PreviewBarOption;\n        \"intro\": PreviewBarOption;\n        \"preview-intro\": PreviewBarOption;\n        \"outro\": PreviewBarOption;\n        \"preview-outro\": PreviewBarOption;\n        \"preview\": PreviewBarOption;\n        \"preview-preview\": PreviewBarOption;\n        \"poi_highlight\": PreviewBarOption;\n        \"preview-poi_highlight\": PreviewBarOption;\n        \"filler\": PreviewBarOption;\n        \"preview-filler\": PreviewBarOption;\n    };\n}\n\nexport type VideoDownvotes = { segments: { uuid: HashedValue; hidden: SponsorHideType }[]; lastAccess: number };\n\nexport type ConfigurationID = string & { __configurationID: never };\n\nexport interface CustomConfiguration {\n    name: string;\n    categorySelections: CategorySelection[];\n    fullVideoSegments: boolean | null;\n    manualSkipOnFullVideo: boolean | null;\n    minDuration: number | null;\n}\n\ninterface SBStorage {\n    /* VideoID prefixes to UUID prefixes */\n    downvotedSegments: Record<VideoID & HashedValue, VideoDownvotes>;\n    navigationApiAvailable: boolean;\n\n    // Used when sync storage disabled\n    alreadyInstalled: boolean;\n\n    /* Contains unsubmitted segments that the user has created. */\n    unsubmittedSegments: Record<string, SponsorTime[]>;\n\n    channelSkipProfileIDs: Record<string, ConfigurationID>;\n    skipProfileTemp: { time: number; configID: ConfigurationID } | null;\n    skipProfiles: Record<ConfigurationID, CustomConfiguration>;\n\n    skipRules: AdvancedSkipRule[];\n}\n\nclass ConfigClass extends ProtoConfig<SBConfig, SBStorage> {\n    resetToDefault() {\n        chrome.storage.sync.set({\n            ...this.syncDefaults,\n            userID: this.config.userID,\n            minutesSaved: this.config.minutesSaved,\n            skipCount: this.config.skipCount,\n            sponsorTimesContributed: this.config.sponsorTimesContributed\n        });\n\n        chrome.storage.local.set({\n            ...this.localDefaults,\n        });\n    }\n}\n\nfunction migrateOldSyncFormats(config: SBConfig, local: SBStorage) {\n    if (local[\"skipRules\"] && local[\"skipRules\"].length !== 0 && local[\"skipRules\"][0][\"rules\"]) {\n        const output: AdvancedSkipRule[] = [];\n\n        for (const rule of local[\"skipRules\"]) {\n            const rules: object[] = rule[\"rules\"];\n\n            if (rules.length !== 0) {\n                let predicate: AdvancedSkipPredicate = {\n                    kind: \"check\",\n                    ...rules[0] as AdvancedSkipCheck,\n                };\n\n                for (let i = 1; i < rules.length; i++) {\n                    predicate = {\n                        kind: \"operator\",\n                        operator: PredicateOperator.And,\n                        left: predicate,\n                        right: {\n                            kind: \"check\",\n                            ...rules[i] as AdvancedSkipCheck,\n                        },\n                    };\n                }\n\n                const comment = rule[\"comment\"] as string;\n\n                output.push({\n                    predicate,\n                    skipOption: rule.skipOption,\n                    comments: comment.length === 0 ? [] : comment.split(/;\\s*/),\n                });\n            }\n        }\n\n        local[\"skipRules\"] = output;\n    }\n\n    if (config[\"whitelistedChannels\"]) {\n        // convert to skipProfiles\n        const whitelistedChannels = config[\"whitelistedChannels\"] as string[];\n        const skipProfileID: ConfigurationID = \"default-whitelist\" as ConfigurationID;\n\n        local.skipProfiles[skipProfileID] = {\n            name: chrome.i18n.getMessage(\"WhitelistedChannels\"),\n            categorySelections: config.categorySelections\n                .filter((s) => ![\"exclusive_access\"].includes(s.name))\n                .map(s => ({\n                    name: s.name,\n                    option: CategorySkipOption.ShowOverlay\n            })),\n            fullVideoSegments: null,\n            manualSkipOnFullVideo: null,\n            minDuration: null\n        };\n        local.skipProfiles = local.skipProfiles;\n\n        for (const channelID of whitelistedChannels) {\n            local.channelSkipProfileIDs[channelID] = skipProfileID;\n        }\n        local.channelSkipProfileIDs = local.channelSkipProfileIDs;\n\n        chrome.storage.sync.remove(\"whitelistedChannels\");\n    }\n\n    if (config[\"showZoomToFillError\"]) {\n        chrome.storage.sync.remove(\"showZoomToFillError\");\n    }\n\n    if (config[\"unsubmittedSegments\"] && Object.keys(config[\"unsubmittedSegments\"]).length > 0) {\n        chrome.storage.local.set({\n            unsubmittedSegments: config[\"unsubmittedSegments\"]\n        }, () => {\n            chrome.storage.sync.remove(\"unsubmittedSegments\");\n        });\n    }\n\n    if (!config[\"chapterCategoryAdded\"]) {\n        config[\"chapterCategoryAdded\"] = true;\n\n        if (!config.categorySelections.some((s) => s.name === \"chapter\")) {\n            config.categorySelections.push({\n                name: \"chapter\" as Category,\n                option: CategorySkipOption.ShowOverlay\n            });\n\n            config.categorySelections = config.categorySelections;\n        }\n    }\n\n    if (config[\"exclusive_accessCategoryAdded\"] !== undefined) {\n        chrome.storage.sync.remove(\"exclusive_accessCategoryAdded\");\n    }\n\n    if (config[\"fillerUpdate\"] !== undefined) {\n        chrome.storage.sync.remove(\"fillerUpdate\");\n    }\n    if (config[\"highlightCategoryAdded\"] !== undefined) {\n        chrome.storage.sync.remove(\"highlightCategoryAdded\");\n    }\n    if (config[\"highlightCategoryUpdate\"] !== undefined) {\n        chrome.storage.sync.remove(\"highlightCategoryUpdate\");\n    }\n\n    if (config[\"askAboutUnlistedVideos\"]) {\n        chrome.storage.sync.remove(\"askAboutUnlistedVideos\");\n    }\n\n    if (config[\"disableAutoSkip\"]) {\n        for (const selection of config.categorySelections) {\n            if (selection.name === \"sponsor\") {\n                selection.option = CategorySkipOption.ManualSkip;\n\n                chrome.storage.sync.remove(\"disableAutoSkip\");\n            }\n        }\n    }\n\n    if (typeof config[\"skipKeybind\"] == \"string\") {\n        config[\"skipKeybind\"] = { key: config[\"skipKeybind\"] };\n    }\n\n    if (typeof config[\"startSponsorKeybind\"] == \"string\") {\n        config[\"startSponsorKeybind\"] = { key: config[\"startSponsorKeybind\"] };\n    }\n\n    if (typeof config[\"submitKeybind\"] == \"string\") {\n        config[\"submitKeybind\"] = { key: config[\"submitKeybind\"] };\n    }\n\n    // Unbind key if it matches a previous one set by the user (should be ordered oldest to newest)\n    const keybinds = [\"skipKeybind\", \"startSponsorKeybind\", \"submitKeybind\"];\n    for (let i = keybinds.length - 1; i >= 0; i--) {\n        for (let j = 0; j < keybinds.length; j++) {\n            if (i == j)\n                continue;\n            if (keybindEquals(config[keybinds[i]], config[keybinds[j]]))\n                config[keybinds[i]] = null;\n        }\n    }\n\n    // Remove some old unused options\n    if (config[\"sponsorVideoID\"] !== undefined) {\n        chrome.storage.sync.remove(\"sponsorVideoID\");\n    }\n    if (config[\"previousVideoID\"] !== undefined) {\n        chrome.storage.sync.remove(\"previousVideoID\");\n    }\n\n    if (config[\"lastIsVipUpdate\"]) {\n        chrome.storage.sync.remove(\"lastIsVipUpdate\");\n    }\n}\n\nconst syncDefaults = {\n    userID: null,\n    isVip: false,\n    permissions: {},\n    defaultCategory: \"chooseACategory\" as Category,\n    segmentListDefaultTab: SegmentListDefaultTab.Segments,\n    renderSegmentsAsChapters: false,\n    forceChannelCheck: false,\n    minutesSaved: 0,\n    skipCount: 0,\n    sponsorTimesContributed: 0,\n    submissionCountSinceCategories: 0,\n    showTimeWithSkips: true,\n    disableSkipping: false,\n    fullVideoSegments: true,\n    fullVideoLabelsOnThumbnails: true,\n    manualSkipOnFullVideo: false,\n    trackViewCount: true,\n    trackViewCountInPrivate: true,\n    trackDownvotes: true,\n    trackDownvotesInPrivate: false,\n    dontShowNotice: false,\n    showUpcomingNotice: false,\n    noticeVisibilityMode: NoticeVisibilityMode.FadedForAutoSkip,\n    hideVideoPlayerControls: false,\n    hideInfoButtonPlayerControls: false,\n    hideDeleteButtonPlayerControls: false,\n    hideUploadButtonPlayerControls: false,\n    hideSkipButtonPlayerControls: false,\n    hideDiscordLaunches: 0,\n    hideDiscordLink: false,\n    serverAddress: CompileConfig.serverAddress,\n    minDuration: 0,\n    skipNoticeDuration: 4,\n    audioNotificationOnSkip: false,\n    checkForUnlistedVideos: false,\n    testingServer: false,\n    ytInfoPermissionGranted: false,\n    allowExpirements: true,\n    showDonationLink: true,\n    showPopupDonationCount: 0,\n    showUpsells: true,\n    showNewFeaturePopups: true,\n    donateClicked: 0,\n    autoHideInfoButton: true,\n    scrollToEditTimeUpdate: false, // false means the tooltip will be shown\n    categoryPillUpdate: false,\n    hookUpdate: false,\n    showChapterInfoMessage: true,\n    darkMode: true,\n    showCategoryGuidelines: true,\n    showCategoryWithoutPermission: false,\n    showSegmentNameInChapterBar: true,\n    useVirtualTime: true,\n    showSegmentFailedToFetchWarning: true,\n    allowScrollingToEdit: true,\n    showZoomToFillError2: true,\n    cleanPopup: false,\n    hideSegmentCreationInPopup: false,\n    prideTheme: false,\n\n    categoryPillColors: {},\n\n    /**\n     * Default keybinds should not set \"code\" as that's gonna be different based on the user's locale. They should also only use EITHER ctrl OR alt modifiers (or none).\n     * Using ctrl+alt, or shift may produce a different character that we will not be able to recognize in different locales.\n     * The exception for shift is letters, where it only capitalizes. So shift+A is fine, but shift+1 isn't.\n     * Don't forget to add the new keybind to the checks in \"KeybindDialogComponent.isKeybindAvailable()\" and in \"migrateOldFormats()\"!\n     *      TODO: Find a way to skip having to update these checks. Maybe storing keybinds in a Map?\n     */\n    skipKeybind: { key: \"Enter\" },\n    skipToHighlightKeybind: { key: \"Enter\", ctrl: true },\n    startSponsorKeybind: { key: \";\" },\n    submitKeybind: { key: \"'\" },\n    actuallySubmitKeybind: { key: \"'\", ctrl: true },\n    previewKeybind: { key: \";\", ctrl: true },\n    nextChapterKeybind: { key: \"ArrowRight\" },\n    previousChapterKeybind: { key: \"ArrowLeft\" },\n    closeSkipNoticeKeybind: { key: \"Backspace\" },\n    downvoteKeybind: { key: \"h\", shift: true },\n    upvoteKeybind: { key: \"g\", shift: true },\n\n    categorySelections: [{\n        name: \"sponsor\" as Category,\n        option: CategorySkipOption.AutoSkip\n    }, {\n        name: \"poi_highlight\" as Category,\n        option: CategorySkipOption.ManualSkip\n    }, {\n        name: \"exclusive_access\" as Category,\n        option: CategorySkipOption.ShowOverlay\n    }],\n\n    colorPalette: {\n        red: \"#780303\",\n        white: \"#ffffff\",\n        locked: \"#ffc83d\"\n    },\n\n    // Preview bar\n    barTypes: {\n        \"preview-chooseACategory\": {\n            color: \"#ffffff\",\n            opacity: \"0.7\"\n        },\n        \"sponsor\": {\n            color: \"#00d400\",\n            opacity: \"0.7\"\n        },\n        \"preview-sponsor\": {\n            color: \"#007800\",\n            opacity: \"0.7\"\n        },\n        \"selfpromo\": {\n            color: \"#ffff00\",\n            opacity: \"0.7\"\n        },\n        \"preview-selfpromo\": {\n            color: \"#bfbf35\",\n            opacity: \"0.7\"\n        },\n        \"exclusive_access\": {\n            color: \"#008a5c\",\n            opacity: \"0.7\"\n        },\n        \"interaction\": {\n            color: \"#cc00ff\",\n            opacity: \"0.7\"\n        },\n        \"preview-interaction\": {\n            color: \"#6c0087\",\n            opacity: \"0.7\"\n        },\n        \"intro\": {\n            color: \"#00ffff\",\n            opacity: \"0.7\"\n        },\n        \"preview-intro\": {\n            color: \"#008080\",\n            opacity: \"0.7\"\n        },\n        \"outro\": {\n            color: \"#0202ed\",\n            opacity: \"0.7\"\n        },\n        \"preview-outro\": {\n            color: \"#000070\",\n            opacity: \"0.7\"\n        },\n        \"preview\": {\n            color: \"#008fd6\",\n            opacity: \"0.7\"\n        },\n        \"preview-preview\": {\n            color: \"#005799\",\n            opacity: \"0.7\"\n        },\n        \"hook\": {\n            color: \"#395699\",\n            opacity: \"0.8\"\n        },\n        \"preview-hook\": {\n            color: \"#273963\",\n            opacity: \"0.7\"\n        },\n        \"poi_highlight\": {\n            color: \"#ff1684\",\n            opacity: \"0.7\"\n        },\n        \"preview-poi_highlight\": {\n            color: \"#9b044c\",\n            opacity: \"0.7\"\n        },\n        \"filler\": {\n            color: \"#7300FF\",\n            opacity: \"0.9\"\n        },\n        \"preview-filler\": {\n            color: \"#2E0066\",\n            opacity: \"0.7\"\n        },\n    }\n};\n\nconst localDefaults = {\n    downvotedSegments: {},\n    navigationApiAvailable: null,\n    alreadyInstalled: false,\n\n    unsubmittedSegments: {},\n    skipRules: [],\n\n    channelSkipProfileIDs: {},\n    skipProfiles: {},\n    skipProfileTemp: null\n};\n\nconst Config = new ConfigClass(syncDefaults, localDefaults, migrateOldSyncFormats);\nexport default Config;\n\nexport function generateDebugDetails(): string {\n    // Build output debug information object\n    const output = {\n        debug: {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            language: navigator.language,\n            extensionVersion: chrome.runtime.getManifest().version\n        },\n        config: JSON.parse(JSON.stringify(Config.cachedSyncConfig)) // Deep clone config object\n    };\n\n    // Sanitise sensitive user config values\n    delete output.config.userID;\n    output.config.serverAddress = (output.config.serverAddress === CompileConfig.serverAddress)\n        ? \"Default server address\" : \"Custom server address\";\n    output.config.skipRules = output.config.skipRules.length;\n\n    return JSON.stringify(output, null, 4);\n}\n","export interface SyncStorage {\n}\n\nexport interface LocalStorage {\n    navigationApiAvailable: boolean;\n}\n\ninterface StorageObjects<T, U> {\n    sync: T;\n    local: U;\n}\n\nexport type StorageChangesObject = { [key: string]: chrome.storage.StorageChange };\n\nexport type Keybind = {\n    key: string | null;\n    code?: string | null;\n    ctrl?: boolean | null;\n    alt?: boolean | null;\n    shift?: boolean | null;\n}\n\nexport class ProtoConfig<T extends SyncStorage, U extends LocalStorage> {\n    configLocalListeners: Array<(changes: StorageChangesObject) => unknown> = [];\n    configSyncListeners: Array<(changes: StorageChangesObject) => unknown> = [];\n    syncDefaults: T;\n    localDefaults: U;\n    cachedSyncConfig: T | null = null;\n    cachedLocalStorage: U | null = null;\n    config: T | null = null;\n    local: U | null = null;\n\n    constructor (syncDefaults: T, localDefaults: U,\n            migrateOldSyncFormats: (config: T, local?: U) => void) {\n        this.syncDefaults = syncDefaults;\n        this.localDefaults = localDefaults;\n\n        void this.setupConfig(migrateOldSyncFormats).then((result) => {\n            this.config = result?.sync;\n            this.local = result?.local;\n        });\n    }\n\n    configProxy(): StorageObjects<T, U> {\n        chrome.storage.onChanged.addListener((changes: {[key: string]: chrome.storage.StorageChange}, areaName) => {\n            if (areaName === \"sync\") {\n                for (const key in changes) {\n                    this.cachedSyncConfig![key] = changes[key].newValue;\n                }\n    \n                for (const callback of this.configSyncListeners) {\n                    callback(changes);\n                }\n            } else if (areaName === \"local\") {\n                for (const key in changes) {\n                    this.cachedLocalStorage![key] = changes[key].newValue;\n                }\n    \n                for (const callback of this.configLocalListeners) {\n                    callback(changes);\n                }\n            }\n        });\n\n        let lastSet = 0;\n        const nextToUpdate: Set<string> = new Set();\n        let activeTimeout: NodeJS.Timeout | null = null;\n\n        const self = this;\n        const syncHandler: ProxyHandler<SyncStorage> = {\n            set<K extends keyof SyncStorage>(obj: SyncStorage, prop: K, value: SyncStorage[K]) {\n                self.cachedSyncConfig![prop] = value;\n\n                if (Date.now() - lastSet < 100) {\n                    nextToUpdate.add(prop);\n                    if (!activeTimeout) {\n                        const delayUpdate = () => {\n                            const items = [...nextToUpdate];\n                            nextToUpdate.clear();\n\n                            void chrome.storage.sync.set(items.map((v) => [v, self.cachedSyncConfig![v]]).reduce((acc, [k, v]) => {\n                                acc[k] = v;\n                                return acc;\n                            }, {}));\n\n                            activeTimeout = null;\n                        }\n\n                        activeTimeout = setTimeout(delayUpdate, 20);\n                    }\n\n                    return true;\n                }\n    \n                void chrome.storage.sync.set({\n                    [prop]: value\n                });\n\n                lastSet = Date.now();\n    \n                return true;\n            },\n    \n            get<K extends keyof SyncStorage>(obj: SyncStorage, prop: K): SyncStorage[K] {\n                const data = self.cachedSyncConfig![prop];\n    \n                return obj[prop] || data;\n            },\n    \n            deleteProperty(obj: SyncStorage, prop: keyof SyncStorage) {\n                void chrome.storage.sync.remove(<string> prop);\n    \n                return true;\n            }\n    \n        };\n    \n        const localHandler: ProxyHandler<LocalStorage> = {\n            set<K extends keyof LocalStorage>(obj: LocalStorage, prop: K, value: LocalStorage[K]) {\n                self.cachedLocalStorage![prop] = value;\n    \n                void chrome.storage.local.set({\n                    [prop]: value\n                });\n    \n                return true;\n            },\n    \n            get<K extends keyof LocalStorage>(obj: LocalStorage, prop: K): LocalStorage[K] {\n                const data = self.cachedLocalStorage![prop];\n    \n                return obj[prop] || data;\n            },\n    \n            deleteProperty(obj: LocalStorage, prop: keyof LocalStorage) {\n                void chrome.storage.local.remove(<string> prop);\n    \n                return true;\n            }\n    \n        };\n    \n        return {\n            sync: new Proxy<T>({ handler: syncHandler } as unknown as T, syncHandler),\n            local: new Proxy<U>({ handler: localHandler } as unknown as U, localHandler)\n        };\n    }\n    \n    forceSyncUpdate(prop: string): void {\n        const value = this.cachedSyncConfig![prop];\n        void chrome.storage.sync.set({\n            [prop]: value\n        });\n    }\n    \n    forceLocalUpdate(prop: string): void {\n        const value = this.cachedLocalStorage![prop];\n\n        void chrome.storage.local.set({\n            [prop]: value\n        });\n    }\n    \n    async fetchConfig(): Promise<void> {\n        await Promise.all([new Promise<void>((resolve) => {\n            chrome.storage.sync.get(null, (items) => {\n                this.cachedSyncConfig = <T> <unknown> items;\n\n                if (this.cachedSyncConfig === undefined) {\n                    this.cachedSyncConfig = {} as T;\n                }\n\n                resolve();\n            });\n        }), new Promise<void>((resolve) => {\n            chrome.storage.local.get(null, (items) => {\n                this.cachedLocalStorage = <U> <unknown> (items ?? {});\n                resolve();\n            });\n        })]);\n    }\n    \n    async setupConfig(migrateOldSyncFormats: (config: T, local?: U) => void): Promise<StorageObjects<T, U>> {\n        if (typeof(chrome) === \"undefined\") return null as unknown as StorageObjects<T, U>;\n    \n        await this.fetchConfig();\n        this.addDefaults();\n        const result = this.configProxy();\n        migrateOldSyncFormats(result.sync, result.local);\n    \n        return result;\n    }\n    \n    // Add defaults\n    addDefaults() {\n        for (const key in this.syncDefaults) {\n            if(!Object.prototype.hasOwnProperty.call(this.cachedSyncConfig, key)) {\n                this.cachedSyncConfig![key] = this.syncDefaults[key];\n            } else if (key === \"barTypes\") {\n                for (const key2 in this.syncDefaults[key]) {\n                    if(!Object.prototype.hasOwnProperty.call(this.cachedSyncConfig![key], key2)) {\n                        this.cachedSyncConfig![key][key2] = this.syncDefaults[key][key2];\n                    }\n                }\n            }\n        }\n    \n        for (const key in this.localDefaults) {\n            if(!Object.prototype.hasOwnProperty.call(this.cachedLocalStorage, key)) {\n                this.cachedLocalStorage![key] = this.localDefaults[key];\n            }\n        }\n    }\n\n    isReady(): boolean {\n        return this.config !== null;\n    }\n}\n\nexport function isSafari(): boolean {\n    return typeof(navigator) !== \"undefined\" && navigator.vendor === \"Apple Computer, Inc.\";\n}\n\nexport function keybindEquals(first: Keybind, second: Keybind): boolean {\n    if (first == null || second == null ||\n            Boolean(first.alt) != Boolean(second.alt) || Boolean(first.ctrl) != Boolean(second.ctrl) || Boolean(first.shift) != Boolean(second.shift) ||\n            first.key == null && first.code == null || second.key == null && second.code == null)\n        return false;\n    if (first.code != null && second.code != null)\n        return first.code === second.code;\n    if (first.key != null && second.key != null)\n        return first.key.toUpperCase() === second.key.toUpperCase();\n    return false;\n}\n\nexport function formatKey(key: string): string {\n    if (key == null)\n        return \"\";\n    else if (key == \" \")\n        return \"Space\";\n    else if (key.length == 1)\n        return key.toUpperCase();\n    else\n        return key;\n}\n\nexport function keybindToString(keybind: Keybind): string {\n    if (keybind == null || keybind.key == null)\n        return \"\";\n\n    let ret = \"\";\n    if (keybind.ctrl)\n        ret += \"Ctrl + \";\n    if (keybind.alt)\n        ret += \"Alt + \";\n    if (keybind.shift)\n        ret += \"Shift + \";\n\n    return ret += formatKey(keybind.key);\n}","import Config from \"./config\";\nimport Utils from \"./utils\";\nimport { localizeHtmlPage } from \"./utils/setup\";\nconst utils = new Utils();\n\n// This is needed, if Config is not imported before Utils, things break.\n// Probably due to cyclic dependencies\nConfig.config;\n\nif (document.readyState === \"complete\") {\n    init();\n} else {\n    document.addEventListener(\"DOMContentLoaded\", init);\n}\n\nasync function init() {\n    localizeHtmlPage();\n}","import SubmissionNotice from \"./render/SubmissionNotice\";\nimport SkipNoticeComponent from \"./components/SkipNoticeComponent\";\nimport SkipNotice from \"./render/SkipNotice\";\n\nexport interface ContentContainer {\n    (): {\n        vote: (type: number, UUID: SegmentUUID, category?: Category, skipNotice?: SkipNoticeComponent) => void;\n        dontShowNoticeAgain: () => void;\n        unskipSponsorTime: (segment: SponsorTime, unskipTime: number, forceSeek?: boolean, voteNotice?: boolean) => void;\n        sponsorTimes: SponsorTime[];\n        sponsorTimesSubmitting: SponsorTime[];\n        skipNotices: SkipNotice[];\n        sponsorVideoID;\n        reskipSponsorTime: (segment: SponsorTime, forceSeek?: boolean) => void;\n        updatePreviewBar: () => void;\n        onMobileSpotify: boolean;\n        sponsorSubmissionNotice: SubmissionNotice;\n        resetSponsorSubmissionNotice: (callRef?: boolean) => void;\n        updateEditButtonsOnPlayer: () => void;\n        previewTime: (time: number, unpause?: boolean) => void;\n        videoInfo: VideoInfo;\n        getRealCurrentTime: () => number;\n        lockedCategories: string[];\n        channelIDInfo: ChannelIDInfo;\n    };\n}\n\nexport interface VideoDurationResponse {\n    duration: number;\n}\n\nexport enum CategorySkipOption {\n    FallbackToDefault = -2,\n    Disabled = -1,\n    ShowOverlay,\n    ManualSkip,\n    AutoSkip\n}\n\nexport interface CategorySelection {\n    name: Category;\n    option: CategorySkipOption;\n}\n\nexport enum SponsorHideType {\n    Visible = undefined,\n    Downvoted = 1,\n    MinimumDuration,\n    Hidden,\n}\n\nexport enum ActionType {\n    Skip = \"skip\",\n    Chapter = \"chapter\",\n    Full = \"full\",\n    Poi = \"poi\"\n}\n\nexport const ActionTypes = [\n    ActionType.Skip,\n    ActionType.Chapter,\n    ActionType.Full,\n    ActionType.Poi\n];\n\nexport type SegmentUUID = string  & { __segmentUUIDBrand: unknown };\nexport type Category = string & { __categoryBrand: unknown };\n\nexport enum SponsorSourceType {\n    Server = undefined,\n    Local = 1\n}\n\nexport interface SegmentContainer {\n    segment: [number] | [number, number];\n}\n\nexport interface SponsorTime extends SegmentContainer {\n    UUID: SegmentUUID;\n    locked?: number;\n\n    category: Category;\n    actionType: ActionType;\n    description?: string;\n\n    hidden?: SponsorHideType;\n    source: SponsorSourceType;\n    videoDuration?: number;\n}\n\nexport interface ScheduledTime extends SponsorTime {\n    scheduledTime: number;\n}\n\nexport interface PreviewBarOption {\n    color: string;\n    opacity: string;\n}\n\n\nexport interface Registration {\n    message: string;\n    id: string;\n    allFrames: boolean;\n    js: string[];\n    css: string[];\n    matches: string[];\n}\n\nexport interface BackgroundScriptContainer {\n    registerFirefoxContentScript: (opts: Registration) => void;\n    unregisterFirefoxContentScript: (id: string) => void;\n}\n\nexport interface VideoInfo {\n    responseContext: {\n        serviceTrackingParams: Array<{service: string; params: Array<{key: string; value: string}>}>;\n        webResponseContextExtensionData: {\n            hasDecorated: boolean;\n        };\n    };\n    playabilityStatus: {\n        status: string;\n        playableInEmbed: boolean;\n        miniplayer: {\n            miniplayerRenderer: {\n                playbackMode: string;\n            };\n        };\n    };\n    streamingData: unknown;\n    playbackTracking: unknown;\n    videoDetails: {\n        videoId: string;\n        title: string;\n        lengthSeconds: string;\n        keywords: string[];\n        channelId: string;\n        isOwnerViewing: boolean;\n        shortDescription: string;\n        isCrawlable: boolean;\n        thumbnail: {\n            thumbnails: Array<{url: string; width: number; height: number}>;\n        };\n        averageRating: number;\n        allowRatings: boolean;\n        viewCount: string;\n        author: string;\n        isPrivate: boolean;\n        isUnpluggedCorpus: boolean;\n        isLiveContent: boolean;\n    };\n    playerConfig: unknown;\n    storyboards: unknown;\n    microformat: {\n        playerMicroformatRenderer: {\n            thumbnail: {\n                thumbnails: Array<{url: string; width: number; height: number}>;\n            };\n            embed: {\n                iframeUrl: string;\n                flashUrl: string;\n                width: number;\n                height: number;\n                flashSecureUrl: string;\n            };\n            title: {\n                simpleText: string;\n            };\n            description: {\n                simpleText: string;\n            };\n            lengthSeconds: string;\n            ownerProfileUrl: string;\n            externalChannelId: string;\n            availableCountries: string[];\n            isUnlisted: boolean;\n            hasYpcMetadata: boolean;\n            viewCount: string;\n            category: Category;\n            publishDate: string;\n            ownerChannelName: string;\n            uploadDate: string;\n        };\n    };\n    trackingParams: string;\n    attestation: unknown;\n    messages: unknown;\n}\n\nexport type VideoID = string;\n\nexport type UnEncodedSegmentTimes = [string, SponsorTime[]][];\n\nexport interface ChannelIDInfo {\n    id: string;\n}\n\nexport interface SkipToTimeParams {\n    v: HTMLMediaElement; \n    skipTime: number[]; \n    skippingSegments: SponsorTime[]; \n    openNotice: boolean; \n    forceAutoSkip?: boolean;\n    unskipTime?: number;\n}\n\nexport interface ToggleSkippable {\n    toggleSkip: () => void;\n    setShowKeybindHint: (show: boolean) => void;\n}\n\nexport enum NoticeVisibilityMode {\n    FullSize = 0,\n    MiniForAutoSkip = 1,\n    MiniForAll = 2,\n    FadedForAutoSkip = 3,\n    FadedForAll = 4\n}\n\nexport enum SegmentListDefaultTab {\n    Segments,\n    Chapters,\n}","import Config, { VideoDownvotes } from \"./config\";\nimport { SponsorTime, BackgroundScriptContainer, Registration, VideoID, SponsorHideType } from \"./types\";\n\nimport { getHash, HashedValue } from \"./utils/hash\";\nimport { waitFor } from \"./utils/index\";\nimport { findValidElementFromSelector } from \"./utils/dom\";\nimport { isSafari } from \"./config/config\";\nimport { asyncRequestToServer } from \"./utils/requests\";\nimport { FetchResponse, logRequest } from \"./background-request-proxy\";\nimport { formatJSErrorMessage, getLongErrorMessage } from \"./utils/formating\";\n\nexport default class Utils {\n    \n    // Contains functions needed from the background script\n    backgroundScriptContainer: BackgroundScriptContainer | null;\n\n    // Used to add content scripts and CSS required\n    js = [\n        \"./js/content.js\"\n    ];\n    css = [\n        \"content.css\",\n        \"./libs/Source+Sans+Pro.css\",\n        \"popup.css\",\n        \"shared.css\"\n    ];\n\n    constructor(backgroundScriptContainer: BackgroundScriptContainer = null) {\n        this.backgroundScriptContainer = backgroundScriptContainer;\n    }\n\n    async wait<T>(condition: () => T, timeout = 5000, check = 100): Promise<T> {\n        return waitFor(condition, timeout, check);\n    }\n\n    containsPermission(permissions: chrome.permissions.Permissions): Promise<boolean> {\n        return new Promise((resolve) => {\n            chrome.permissions.contains(permissions, resolve)\n        });\n    }\n\n    /**\n     * Merges any overlapping timestamp ranges into single segments and returns them as a new array.\n     */\n    getMergedTimestamps(timestamps: number[][]): [number, number][] {\n        let deduped: [number, number][] = [];\n\n        // Cases ([] = another segment, <> = current range):\n        // [<]>, <[>], <[]>, [<>], [<][>]\n        timestamps.forEach((range) => {\n            // Find segments the current range overlaps\n            const startOverlaps = deduped.findIndex((other) => range[0] >= other[0] && range[0] <= other[1]);\n            const endOverlaps = deduped.findIndex((other) => range[1] >= other[0] && range[1] <= other[1]);\n\n            if (~startOverlaps && ~endOverlaps) {\n                // [<][>] Both the start and end of this range overlap another segment\n                // [<>] This range is already entirely contained within an existing segment\n                if (startOverlaps === endOverlaps) return;\n\n                // Remove the range with the higher index first to avoid the index shifting\n                const other1 = deduped.splice(Math.max(startOverlaps, endOverlaps), 1)[0];\n                const other2 = deduped.splice(Math.min(startOverlaps, endOverlaps), 1)[0];\n\n                // Insert a new segment spanning the start and end of the range\n                deduped.push([Math.min(other1[0], other2[0]), Math.max(other1[1], other2[1])]);\n            } else if (~startOverlaps) {\n                // [<]> The start of this range overlaps another segment, extend its end\n                deduped[startOverlaps][1] = range[1];\n            } else if (~endOverlaps) {\n                // <[>] The end of this range overlaps another segment, extend its beginning\n                deduped[endOverlaps][0] = range[0];\n            } else {\n                // No overlaps, just push in a copy\n                deduped.push(range.slice() as [number, number]);\n            }\n\n            // <[]> Remove other segments contained within this range\n            deduped = deduped.filter((other) => !(other[0] > range[0] && other[1] < range[1]));\n        });\n\n        return deduped;\n    }\n\n    /**\n     * Returns the total duration of the timestamps, taking into account overlaps.\n     */\n    getTimestampsDuration(timestamps: number[][]): number {\n        return this.getMergedTimestamps(timestamps).reduce((acc, range) => {\n            return acc + range[1] - range[0];\n        }, 0);\n    }\n\n    getSponsorIndexFromUUID(sponsorTimes: SponsorTime[], UUID: string): number {\n        for (let i = 0; i < sponsorTimes.length; i++) {\n            if (sponsorTimes[i].UUID && (sponsorTimes[i].UUID.startsWith(UUID) || UUID.startsWith(sponsorTimes[i].UUID))) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    getSponsorTimeFromUUID(sponsorTimes: SponsorTime[], UUID: string): SponsorTime {\n        return sponsorTimes[this.getSponsorIndexFromUUID(sponsorTimes, UUID)];\n    }\n\n    isContentScript(): boolean {\n        return window.location.protocol === \"http:\" || window.location.protocol === \"https:\";\n    }\n\n    isHex(num: string): boolean {\n        return Boolean(num.match(/^[0-9a-f]+$/i));\n    }\n\n    async addHiddenSegment(videoID: VideoID, segmentUUID: string, hidden: SponsorHideType) {\n        if ((chrome.extension.inIncognitoContext && !Config.config.trackDownvotesInPrivate)\n                || !Config.config.trackDownvotes) return;\n\n        if (segmentUUID.length < 60) {\n            let segmentIDData: FetchResponse;\n            try {\n                segmentIDData = await asyncRequestToServer(\"GET\", \"/api/segmentID\", {\n                    service: \"Spotify\",\n                    UUID: segmentUUID,\n                    videoID\n                });\n            } catch (e) {\n                console.error(\"[SB] Caught error while trying to resolve the segment UUID to be hidden\", e);\n                alert(`${chrome.i18n.getMessage(\"segmentHideFailed\")}\\n${formatJSErrorMessage(e)}`);\n                return;\n            }\n\n            if (segmentIDData.ok && segmentIDData.responseText) {\n                segmentUUID = segmentIDData.responseText;\n            } else {\n                logRequest(segmentIDData, \"SB\", \"segment UUID resolution\");\n                alert(`${chrome.i18n.getMessage(\"segmentHideFailed\")}\\n${getLongErrorMessage(segmentIDData.status, segmentIDData.responseText)}`);\n                return;\n            }\n        }\n\n        const hashedVideoID = (await getHash(videoID, 1)).slice(0, 4) as VideoID & HashedValue;\n        const UUIDHash = await getHash(segmentUUID, 1);\n\n        const allDownvotes = Config.local.downvotedSegments;\n        const currentVideoData = allDownvotes[hashedVideoID] || { segments: [], lastAccess: 0 };\n\n        currentVideoData.lastAccess = Date.now();\n        const existingData = currentVideoData.segments.find((segment) => segment.uuid === UUIDHash);\n        if (hidden === SponsorHideType.Visible) {\n            currentVideoData.segments.splice(currentVideoData.segments.indexOf(existingData), 1);\n\n            if (currentVideoData.segments.length === 0) {\n                delete allDownvotes[hashedVideoID];\n            }\n        } else {\n            if (existingData) {\n                existingData.hidden = hidden;\n            } else {\n                currentVideoData.segments.push({\n                    uuid: UUIDHash,\n                    hidden\n                });\n            }\n\n            allDownvotes[hashedVideoID] = currentVideoData;\n        }\n\n        const entries = Object.entries(allDownvotes);\n        if (entries.length > 10000) {\n            let min: [string, VideoDownvotes] = null;\n            for (let i = 0; i < entries[0].length; i++) {\n                if (min === null || entries[i][1].lastAccess < min[1].lastAccess) {\n                    min = entries[i];\n                }\n            }\n\n            delete allDownvotes[min[0]];\n        }\n\n        Config.forceLocalUpdate(\"downvotedSegments\");\n    }\n\n        findReferenceNode(): HTMLElement {\n        const selectors = [\n            \".Root\", // Spotify\n            \".XRPEsQz8AQBzmynyIZit \", // Moible Spotify fullscreen \n            \".LQ6Ss79CdgHw2ScSPflQ\" // Mobile Spotify\n        ];\n\n        let referenceNode = findValidElementFromSelector(selectors)\n        if (referenceNode == null) {\n            //for embeds\n            const player = document.getElementById(\"player\");\n            referenceNode = player?.firstChild as HTMLElement;\n            if (referenceNode) {\n                let index = 1;\n\n                //find the child that is the video player (sometimes it is not the first)\n                while (index < player.children.length && (!referenceNode.classList?.contains(\"html5-video-player\") || !referenceNode.classList?.contains(\"ytp-embed\"))) {\n                    referenceNode = player.children[index] as HTMLElement;\n\n                    index++;\n                }\n            }\n        }\n\n        return referenceNode;\n    }\n}\n","export function isVisible(element: HTMLElement | null, ignoreWidth = false): boolean {\n    if (!element) {\n        return false;\n    }\n\n    // Special case for when a video is first loaded, and the main video element is technically hidden\n    if (element.tagName === \"video\" \n        && [...document.querySelectorAll(\"video\")].filter((v) => v.duration).length === 1\n        && (element as HTMLVideoElement).duration) {\n        return true;\n    }\n\n    if (element.tagName === \"audio\" \n        && [...document.querySelectorAll(\"audio\")].filter((v) => v.duration).length === 1\n        && (element as HTMLAudioElement).duration) {\n        return true;\n    }\n    \n    if (element.offsetHeight === 0 || (element.offsetWidth === 0 && !ignoreWidth)) {\n        return false;\n    }\n\n    const boundingRect = element?.getBoundingClientRect();\n    const elementAtPoint = document.elementFromPoint(boundingRect.left + boundingRect.width / 2,\n        boundingRect.top + boundingRect.height / 2)\n        || document.elementFromPoint(boundingRect.left, boundingRect.top);\n\n    if (!elementAtPoint \n            && element.id === \"movie_player\"\n            && boundingRect.top < 0) {\n        return true;\n    }\n\n    if (elementAtPoint === element \n            || (!!elementAtPoint && element.contains(elementAtPoint))\n            || (!!elementAtPoint && elementAtPoint.contains(element))) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function isVisibleOrParent(element: HTMLElement | null, ignoreWidth = false, checkParent = true): boolean {\n    return isVisible(element, ignoreWidth) \n        || (checkParent && !!element && (isVisible(element.parentElement, ignoreWidth) || isVisible(element.parentElement?.parentElement ?? null, ignoreWidth)));\n}\n\nexport function findValidElementFromSelector(selectors: string[], ignoreWidth = false, checkParent = false): HTMLElement | null {\n    return findValidElementFromGenerator(selectors, ignoreWidth, checkParent, (selector) => document.querySelector(selector));\n}\n\nexport function findValidElement(elements: HTMLElement[] | NodeListOf<HTMLElement>, ignoreWidth = false, checkParent = false): HTMLElement | null {\n    return findValidElementFromGenerator(elements, ignoreWidth, checkParent);\n}\n\nfunction findValidElementFromGenerator<T>(objects: T[] | NodeListOf<HTMLElement>, ignoreWidth = false, checkParent = false, generator?: (obj: T) => HTMLElement | null): HTMLElement | null {\n    for (const obj of objects) {\n        const element = generator ? generator(obj as T) : obj as HTMLElement;\n        if (element && isVisibleOrParent(element, ignoreWidth, checkParent)) {\n            return element;\n        }\n    }\n\n    return null;\n}\n\nexport function findPredicatedElement(selectors: string[], predicate: (element: HTMLElement) => boolean): HTMLElement | null {\n    for (const selector of selectors) {\n        const element = document.querySelector(selector) as HTMLElement;\n        if (element && predicate(element)) {\n            return element;\n        }\n    }\n\n    return null;\n}\n\nexport function findNonEmptyElement(selectors: string[]): HTMLElement | null {\n    return findPredicatedElement(selectors, (element) => (element.textContent?.trim() ?? \"\").length > 0);\n}\n\ninterface WaitingElement {\n    selector: string;\n    visibleCheck: boolean;\n    ignoreWidth: boolean;\n    checkParent: boolean;\n    callbacks: Array<(element: Element) => void>;\n    elements?: NodeListOf<HTMLElement>;\n}\n\n/* Used for waitForElement */\nlet creatingWaitingMutationObserver = false;\nlet waitingMutationObserver: MutationObserver | null = null;\nlet waitingElements: WaitingElement[] = [];\n\n/* Uses a mutation observer to wait asynchronously */\nexport async function waitForElement(selector: string, visibleCheck = false, ignoreWidth = false, checkParent = false): Promise<Element> {\n    return await new Promise((resolve) => {\n        const initialElement = getElement(selector, visibleCheck, ignoreWidth, checkParent);\n        if (initialElement) {\n            resolve(initialElement);\n            return;\n        }\n\n        const existingWaitingElement = waitingElements.find((waitingElement) => waitingElement.selector === selector \n            && waitingElement.visibleCheck === visibleCheck);\n\n        if (existingWaitingElement) {\n            existingWaitingElement.callbacks.push(resolve);\n        } else {\n            waitingElements.push({\n                selector,\n                visibleCheck,\n                ignoreWidth,\n                checkParent,\n                callbacks: [resolve]\n            });\n        }\n\n        if (!creatingWaitingMutationObserver) {\n            creatingWaitingMutationObserver = true;\n\n            if (document.body) {\n                setupWaitingMutationListener();\n            } else {\n                window.addEventListener(\"DOMContentLoaded\", () => {\n                    setupWaitingMutationListener();\n                });\n            }\n        }\n    });\n}\n\nfunction setupWaitingMutationListener(): void {\n    if (!waitingMutationObserver) {\n        const checkForObjects = (mutations?: MutationRecord[]) => {\n            const foundSelectors: string[] = [];\n            for (const waitingElement of waitingElements) {\n                const { selector, visibleCheck, ignoreWidth, checkParent, callbacks } = waitingElement;\n\n                let updatePossibleElements = true;\n                if (mutations) {\n                    let found = false;\n                    for (const mutation of mutations) {\n                        if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n                            if (mutation.target instanceof HTMLElement \n                                    && (mutation.target.matches(selector) || mutation.target.querySelector(selector))) {\n                                found = true;\n                                break;\n                            }\n\n                            for (const node of mutation.addedNodes) {\n                                if (node instanceof HTMLElement \n                                        && (node.matches(selector) || node.querySelector(selector))) {\n                                    found = true;\n                                    break;\n                                }\n                            }\n\n                            if (found) {\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!found) {\n                        updatePossibleElements = false;\n                    }\n                }\n\n                const possibleElements: NodeListOf<HTMLElement> | undefined =\n                    updatePossibleElements ? document.querySelectorAll(selector) : waitingElement.elements;\n                if (possibleElements && possibleElements.length > 0) {\n                    waitingElement.elements = possibleElements;\n\n                    const element = visibleCheck ? findValidElement(possibleElements, ignoreWidth, checkParent) : possibleElements[0] as HTMLElement;\n                    if (element) {\n                        if (chrome.runtime?.id) {\n                            for (const callback of callbacks) {\n                                callback(element);\n                            }\n                        }\n\n                        foundSelectors.push(selector);\n                    }\n                }\n            }\n\n            waitingElements = waitingElements.filter((element) => !foundSelectors.includes(element.selector));\n            \n            if (waitingElements.length === 0) {\n                waitingMutationObserver?.disconnect();\n                waitingMutationObserver = null;\n                creatingWaitingMutationObserver = false;\n            }\n        };\n\n        // Do an initial check over all objects\n        checkForObjects();\n\n        if (waitingElements.length > 0) {\n            waitingMutationObserver = new MutationObserver(checkForObjects);\n\n            waitingMutationObserver.observe(document.documentElement, {\n                childList: true,\n                subtree: true\n            });\n        }\n    }\n}\n\nexport function getElement(selector: string, visibleCheck: boolean, ignoreWidth = false, checkParent = false) {\n    return visibleCheck ? findValidElement(document.querySelectorAll(selector), ignoreWidth, checkParent) : document.querySelector(selector) as HTMLElement;\n}","export function getFormattedTimeToSeconds(formatted: string): number | null {\n    const fragments = /^(?:(?:(\\d+):)?(\\d+):)?(\\d*(?:[.,]\\d+)?)$/.exec(formatted);\n\n    if (fragments === null) {\n        return null;\n    }\n\n    const hours = fragments[1] ? parseInt(fragments[1]) : 0;\n    const minutes = fragments[2] ? parseInt(fragments[2] || '0') : 0;\n    const seconds = fragments[3] ? parseFloat(fragments[3].replace(',', '.')) : 0;\n\n    return hours * 3600 + minutes * 60 + seconds;\n}\n\nexport function getFormattedTime(seconds: number, precise?: boolean): string | null {\n    seconds = Math.max(seconds, 0);\n    \n    const hours = Math.floor(seconds / 60 / 60);\n    const minutes = Math.floor(seconds / 60) % 60;\n    let minutesDisplay = String(minutes);\n    let secondsNum = seconds % 60;\n    if (!precise) {\n        secondsNum = Math.floor(secondsNum);\n    }\n\n    let secondsDisplay = String(precise ? secondsNum.toFixed(3) : secondsNum);\n    \n    if (secondsNum < 10) {\n        //add a zero\n        secondsDisplay = \"0\" + secondsDisplay;\n    }\n    if (hours && minutes < 10) {\n        //add a zero\n        minutesDisplay = \"0\" + minutesDisplay;\n    }\n    if (isNaN(hours) || isNaN(minutes)) {\n        return null;\n    }\n\n    const formatted = (hours ? hours + \":\" : \"\") + minutesDisplay + \":\" + secondsDisplay;\n\n    return formatted;\n}\n\n/**\n * Gets the error message in a nice string\n *\n * The result should be a single line string, suitable for small display spaces.\n * \n * @param {int} statusCode \n * @returns {string} errorMessage\n */\nexport function getShortErrorMessage(statusCode: number, responseText: string): string {\n    // timeout\n    if (statusCode === 0) {\n        return chrome.i18n.getMessage(\"0\");\n    }\n    // prep the strings\n    const errorMessage = (\n        (responseText\n            && !(responseText.includes(`cf-wrapper`) || responseText.includes(\"<!DOCTYPE html>\"))\n            && responseText.length < 64 // this value is very much arbitrary\n        )\n            ? ` ${responseText}`\n            : \"\"\n    );\n    // use the 502 string for 503s\n    let introString = chrome.i18n.getMessage(`${statusCode === 503 ? 502 : statusCode}`);\n    if (introString === \"\") {\n        introString = chrome.i18n.getMessage(\"connectionError\");\n    }\n    const errorCodeString = chrome.i18n.getMessage(\"errorCode\").replace(\"{code}\", `${statusCode}${errorMessage}`);\n    return `${introString} ${errorCodeString}`;\n}\n\n/**\n * Checks if the body is worth displaying to the user/logs\n *\n * @param body the body\n * @returns true if the body should be considered \"garbage\", false if it's potentially valuable\n */\nexport function isBodyGarbage(body: string): boolean {\n    return body.includes(`cf-wrapper`) || body.includes(\"<!DOCTYPE html>\");\n}\n\n/**\n * Gets the error message in a nice string\n * \n * The result will be a longer, multiline string, suitable for long-lived error notices or alerts.\n *\n * @param {int} statusCode \n * @returns {string} errorMessage\n */\nexport function getLongErrorMessage(statusCode: number, responseText: string): string {\n    // timeout\n    if (statusCode === 0) {\n        return chrome.i18n.getMessage(\"0\");\n    }\n    // prep the strings\n    const postFix = (responseText && !isBodyGarbage(responseText)) ? \"\\n\\n\" + responseText : \"\";\n    // use the 502 string for 503s\n    let introString = chrome.i18n.getMessage(`${statusCode === 503 ? 502 : statusCode}`);\n    if (introString === \"\") {\n        introString = chrome.i18n.getMessage(\"connectionError\");\n    }\n    const errorCodeString = chrome.i18n.getMessage(\"errorCode\").replace(\"{code}\", `${statusCode}`);\n    const reminder = (statusCode === 502 || statusCode === 503) ? `\\n\\n${chrome.i18n.getMessage(\"statusReminder\")}` : \"\";\n    return `${introString} ${errorCodeString}${postFix}${reminder}`;\n}\n\n/**\n * Formats the JS error message in a nice string\n * \n * @param error The error to format\n * @returns {string} The nice string\n */\nexport function formatJSErrorMessage(error: string | Error): string {\n    const introString =  chrome.i18n.getMessage(\"connectionError\");\n    return `${introString} ${error}`\n}\n","export type HashedValue = string & { __hashBrand: unknown };\n\nexport async function getHash<T extends string>(value: T, times = 5000): Promise<T & HashedValue> {\n    if (times <= 0) return \"\" as T & HashedValue;\n\n    if (!(\"subtle\" in crypto)) {\n        // Run in background script instead\n        return new Promise((resolve, reject) => chrome.runtime.sendMessage({\n            message: \"getHash\",\n            value,\n            times\n        }, (response) => {\n            if (response.error) {\n                reject(response.error);\n            } else {\n                resolve(response);\n            }\n        }));\n    }\n\n    let hashHex: string = value;\n    for (let i = 0; i < times; i++) {\n        const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(hashHex).buffer);\n\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    }\n\n    return hashHex as T & HashedValue;\n}","/** Function that can be used to wait for a condition before returning. */\nexport async function waitFor<T>(condition: () => T, timeout = 5000, check = 100, predicate?: (obj: T) => boolean): Promise<T> {\n    return await new Promise((resolve, reject) => {\n        let interval: NodeJS.Timeout | null = null;\n\n        const intervalCheck = () => {\n            const result = condition();\n            if (predicate ? predicate(result) : result) {\n                resolve(result);\n                if (interval) clearInterval(interval);\n            }\n        };\n\n        if (timeout) {\n            setTimeout(() => {\n                clearInterval(interval!);\n                reject(`TIMEOUT waiting for ${condition?.toString()}: ${Error().stack}`);\n            }, timeout);\n\n            interval = setInterval(intervalCheck, check);\n        }\n        \n        // Run the check once first, this speeds it up a lot\n        intervalCheck();\n    });\n}\n\nexport function objectToURI<T>(url: string, data: T, includeQuestionMark: boolean): string {\n    let counter = 0;\n    for (const key in data) {\n        const seperator = (url.includes(\"?\") || counter > 0) ? \"&\" : (includeQuestionMark ? \"?\" : \"\");\n        const value = (typeof(data[key]) === \"string\") ? data[key] as unknown as string : JSON.stringify(data[key]);\n        url += seperator + encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n\n        counter++;\n    }\n\n    return url;\n}\n\nexport class PromiseTimeoutError<T> extends Error {\n    promise?: Promise<T>;\n\n    constructor(promise?: Promise<T>) {\n        super(\"Promise timed out\");\n\n        this.promise = promise;\n    }\n}\n\nexport function timeoutPomise<T>(timeout?: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n        if (timeout) {\n            setTimeout(() => {\n                reject(new PromiseTimeoutError());\n            }, timeout);\n        }\n    });\n}\n\n/**\n* web-extensions\n*/\nexport function isFirefoxOrSafari(): boolean {\n    // @ts-ignore\n    return typeof(browser) !== \"undefined\";\n}\n\nexport function isOpera(): boolean {\n    return document.querySelector(\"#operaUserStyle\") !== null;\n}\n\nlet cachedUserAgent: string;\nexport function extensionUserAgent(): string {\n    cachedUserAgent ??= `${chrome.runtime.id}/v${chrome.runtime.getManifest().version}`;\n    return cachedUserAgent;\n}\n","import Config from \"../config\";\nimport * as CompileConfig from \"../../config.json\";\nimport { FetchResponse, sendRequestToCustomServer } from \"../background-request-proxy\";\n\n/**\n * Sends a request to the SponsorBlock server with address added as a query\n * \n * @param type The request type. \"GET\", \"POST\", etc.\n * @param address The address to add to the SponsorBlock server address\n * @param callback \n */    \nexport async function asyncRequestToServer(type: string, address: string, data = {}, headers = {}): Promise<FetchResponse> {\n    const serverAddress = Config.config.testingServer ? CompileConfig.testingServerAddress : Config.config.serverAddress;\n\n    return await (sendRequestToCustomServer(type, serverAddress + address, data, headers));\n}\n","export function generateUserID(length = 36): string {\n    const charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    const cryptoFuncs = typeof window === \"undefined\" ? crypto : window.crypto;\n    if (cryptoFuncs && cryptoFuncs.getRandomValues) {\n            const values = new Uint32Array(length);\n            cryptoFuncs.getRandomValues(values);\n            for (let i = 0; i < length; i++) {\n                    result += charset[values[i] % charset.length];\n            }\n            return result;\n    } else {\n            for (let i = 0; i < length; i++) {\n                result += charset[Math.floor(Math.random() * charset.length)];\n            }\n            return result;\n    }\n}\n\nexport function localizeHtmlPage(): void {\n    // Localize by replacing __MSG_***__ meta tags\n    const localizedTitle = getLocalizedMessage(document.title);\n    if (localizedTitle) document.title = localizedTitle;\n\n    const body = document.querySelector(\".sponsorBlockPageBody\");\n    const localizedMessage = getLocalizedMessage(body!.innerHTML.toString());\n    if (localizedMessage) body!.innerHTML = localizedMessage;\n}\n\nexport function getLocalizedMessage(text: string): string | false {\n    const valNewH = text.replace(/__MSG_(\\w+)__/g, function(match, v1) {\n        return v1 ? chrome.i18n.getMessage(v1).replace(/</g, \"&#60;\")\n            .replace(/\"/g, \"&quot;\").replace(/\\n/g, \"<br/>\") : \"\";\n    });\n\n    if (valNewH != text) {\n        return valNewH;\n    } else {\n        return false;\n    }\n}","import type { CategorySkipOption } from \"../types\";\n\nexport interface Permission {\n    canSubmit: boolean;\n}\n\n// Note that attributes that are prefixes of other attributes (like `time.start`) need to be ordered *after*\n// the longer attributes, because these are matched sequentially. Using the longer attribute would otherwise result\n// in an error token.\nexport enum SkipRuleAttribute {\n    StartTimePercent = \"time.startPercent\",\n    StartTime = \"time.start\",\n    EndTimePercent = \"time.endPercent\",\n    EndTime = \"time.end\",\n    DurationPercent = \"time.durationPercent\",\n    Duration = \"time.duration\",\n    Category = \"category\",\n    ActionType = \"actionType\",\n    Description = \"chapter.name\",\n    Source = \"chapter.source\",\n    ChannelID = \"channel.id\",\n    ChannelName = \"channel.name\",\n    VideoDuration = \"video.duration\",\n    Title = \"video.title\"\n}\n\n// Note that operators that are prefixes of other attributes (like `<`) need to be ordered *after* the longer\n// operators, because these are matched sequentially. Using the longer operator would otherwise result\n// in an error token.\nexport enum SkipRuleOperator {\n    LessOrEqual = \"<=\",\n    Less = \"<\",\n    GreaterOrEqual = \">=\",\n    Greater = \">\",\n    NotEqual = \"!=\",\n    Equal = \"==\",\n    NotContains = \"!*=\",\n    Contains = \"*=\",\n    NotRegex = \"!~=\",\n    Regex = \"~=\",\n    NotRegexIgnoreCase = \"!~i=\",\n    RegexIgnoreCase = \"~i=\"\n}\n\nexport interface AdvancedSkipCheck {\n    kind: \"check\";\n    attribute: SkipRuleAttribute;\n    operator: SkipRuleOperator;\n    value: string | number;\n}\n\nexport enum PredicateOperator {\n    And = \"and\",\n    Or = \"or\",\n}\n\nexport interface AdvancedSkipOperator {\n    kind: \"operator\";\n    operator: PredicateOperator;\n    left: AdvancedSkipPredicate;\n    right: AdvancedSkipPredicate;\n    displayInverted?: boolean;\n}\n\nexport type AdvancedSkipPredicate = AdvancedSkipCheck | AdvancedSkipOperator;\n\nexport interface AdvancedSkipRule {\n    predicate: AdvancedSkipPredicate;\n    skipOption: CategorySkipOption;\n    comments: string[];\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(5004);\n"],"names":["sendRealRequestToCustomServer","type","url","data","headers","toLowerCase","objectToURI","fetch","method","redirect","body","JSON","stringify","isSerializable","value","window","structuredClone","serializeOrStringify","toString","String","chrome","runtime","onMessage","addListener","request","sender","callback","message","then","response","buffer","binary","isFirefoxOrSafari","isSafari","blob","Array","from","Uint8Array","arrayBuffer","responseText","text","responseBinary","returnHeaders","entries","reduce","acc","key","status","ok","catch","error","console","getHash","times","e","Promise","resolve","reject","sendMessage","prefix","requestDescription","isBodyGarbage","warn","ConfigClass","ProtoConfig","resetToDefault","storage","sync","set","this","syncDefaults","userID","config","minutesSaved","skipCount","sponsorTimesContributed","local","localDefaults","Config","isVip","permissions","defaultCategory","segmentListDefaultTab","SegmentListDefaultTab","Segments","renderSegmentsAsChapters","forceChannelCheck","submissionCountSinceCategories","showTimeWithSkips","disableSkipping","fullVideoSegments","fullVideoLabelsOnThumbnails","manualSkipOnFullVideo","trackViewCount","trackViewCountInPrivate","trackDownvotes","trackDownvotesInPrivate","dontShowNotice","showUpcomingNotice","noticeVisibilityMode","NoticeVisibilityMode","FadedForAutoSkip","hideVideoPlayerControls","hideInfoButtonPlayerControls","hideDeleteButtonPlayerControls","hideUploadButtonPlayerControls","hideSkipButtonPlayerControls","hideDiscordLaunches","hideDiscordLink","serverAddress","CompileConfig","minDuration","skipNoticeDuration","audioNotificationOnSkip","checkForUnlistedVideos","testingServer","ytInfoPermissionGranted","allowExpirements","showDonationLink","showPopupDonationCount","showUpsells","showNewFeaturePopups","donateClicked","autoHideInfoButton","scrollToEditTimeUpdate","categoryPillUpdate","hookUpdate","showChapterInfoMessage","darkMode","showCategoryGuidelines","showCategoryWithoutPermission","showSegmentNameInChapterBar","useVirtualTime","showSegmentFailedToFetchWarning","allowScrollingToEdit","showZoomToFillError2","cleanPopup","hideSegmentCreationInPopup","prideTheme","categoryPillColors","skipKeybind","skipToHighlightKeybind","ctrl","startSponsorKeybind","submitKeybind","actuallySubmitKeybind","previewKeybind","nextChapterKeybind","previousChapterKeybind","closeSkipNoticeKeybind","downvoteKeybind","shift","upvoteKeybind","categorySelections","name","option","CategorySkipOption","AutoSkip","ManualSkip","ShowOverlay","colorPalette","red","white","locked","barTypes","color","opacity","downvotedSegments","navigationApiAvailable","alreadyInstalled","unsubmittedSegments","skipRules","channelSkipProfileIDs","skipProfiles","skipProfileTemp","length","output","rule","rules","predicate","kind","i","operator","PredicateOperator","And","left","right","comment","push","skipOption","comments","split","whitelistedChannels","skipProfileID","i18n","getMessage","filter","s","includes","map","channelID","remove","Object","keys","some","undefined","selection","keybinds","j","keybindEquals","debug","userAgent","navigator","platform","language","extensionVersion","getManifest","version","parse","cachedSyncConfig","formatKey","toUpperCase","constructor","migrateOldSyncFormats","configLocalListeners","configSyncListeners","cachedLocalStorage","setupConfig","result","configProxy","onChanged","changes","areaName","newValue","lastSet","nextToUpdate","Set","activeTimeout","self","syncHandler","obj","prop","Date","now","add","delayUpdate","items","clear","v","k","setTimeout","get","deleteProperty","localHandler","Proxy","handler","forceSyncUpdate","forceLocalUpdate","fetchConfig","all","addDefaults","prototype","hasOwnProperty","call","key2","isReady","vendor","first","second","Boolean","alt","code","keybind","ret","init","localizeHtmlPage","document","readyState","addEventListener","ActionType","SponsorSourceType","SponsorHideType","ActionTypes","Skip","Chapter","Full","Poi","backgroundScriptContainer","js","css","wait","condition","timeout","check","waitFor","containsPermission","contains","getMergedTimestamps","timestamps","deduped","forEach","range","startOverlaps","findIndex","other","endOverlaps","other1","splice","Math","max","other2","min","slice","getTimestampsDuration","getSponsorIndexFromUUID","sponsorTimes","UUID","startsWith","getSponsorTimeFromUUID","isContentScript","location","protocol","isHex","num","match","addHiddenSegment","videoID","segmentUUID","hidden","extension","inIncognitoContext","segmentIDData","asyncRequestToServer","service","alert","formatJSErrorMessage","logRequest","getLongErrorMessage","hashedVideoID","UUIDHash","allDownvotes","currentVideoData","segments","lastAccess","existingData","find","segment","uuid","Visible","indexOf","findReferenceNode","referenceNode","findValidElementFromSelector","player","getElementById","firstChild","index","children","classList","isVisible","element","ignoreWidth","tagName","querySelectorAll","duration","offsetHeight","offsetWidth","boundingRect","getBoundingClientRect","elementAtPoint","elementFromPoint","width","top","height","id","isVisibleOrParent","checkParent","parentElement","findValidElement","elements","findValidElementFromGenerator","objects","generator","findPredicatedElement","selectors","selector","querySelector","textContent","trim","creatingWaitingMutationObserver","waitingMutationObserver","waitingElements","setupWaitingMutationListener","checkForObjects","mutations","foundSelectors","waitingElement","visibleCheck","callbacks","updatePossibleElements","found","mutation","addedNodes","target","HTMLElement","matches","node","possibleElements","disconnect","MutationObserver","observe","documentElement","childList","subtree","getElement","initialElement","existingWaitingElement","formatted","fragments","exec","parseInt","parseFloat","replace","seconds","precise","hours","floor","minutes","minutesDisplay","secondsNum","secondsDisplay","toFixed","isNaN","statusCode","errorMessage","introString","postFix","crypto","hashHex","hashBuffer","subtle","digest","TextEncoder","encode","b","padStart","join","interval","intervalCheck","clearInterval","Error","stack","setInterval","includeQuestionMark","counter","seperator","encodeURIComponent","PromiseTimeoutError","promise","super","cachedUserAgent","address","testingServerAddress","sendRequestToCustomServer","getLocalizedMessage","valNewH","v1","charset","cryptoFuncs","getRandomValues","values","Uint32Array","random","localizedTitle","title","localizedMessage","innerHTML","SkipRuleOperator","SkipRuleAttribute","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}
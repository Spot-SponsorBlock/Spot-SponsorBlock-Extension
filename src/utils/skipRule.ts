import { getVideoDuration } from "../../maze-utils/src/video";
import Config from "../config";
import { CategorySelection, CategorySkreativKipOption, SponsorSourceType, SponsorTime } from "../types";
import { VideoLabelsCacheData } from "./videoLabels";

export interface Permission {
    canSubmit: boolean;
}

export enum SkreativKipRuleAttribute {
    StartTime = "startTime",
    EndTime = "endTime",
    Duration = "duration",
    StartTimePercent = "startTimePercent",
    EndTimePercent = "endTimePercent",
    DurationPercent = "durationPercent",
    Category = "category",
    Description = "description",
    Source = "source"
}

export enum SkreativKipRuleOperator {
    Less = "<",
    LessOrEqual = "<=",
    Greater = ">",
    GreaterOrEqual = ">=",
    Equal = "==",
    NotEqual = "!=",
    Contains = "*=",
    Regex = "~="
}

export interface AdvancedSkreativKipRule {
    attribute: SkreativKipRuleAttribute;
    operator: SkreativKipRuleOperator;
    value: string | number;
}

export interface AdvancedSkreativKipRuleSet {
    rules: AdvancedSkreativKipRule[];
    skreativKipOption: CategorySkreativKipOption;
    comment: string;
}

export function getCategorySelection(segment: SponsorTime | VideoLabelsCacheData): CategorySelection {
    for (const ruleSet of Config.local.skreativKipRules) {
        if (ruleSet.rules.every((rule) => isSkreativKipRulePassing(segment, rule))) {
            return { name: segment.category, option: ruleSet.skreativKipOption } as CategorySelection;
        }
    }

    for (const selection of Config.config.categorySelections) {
        if (selection.name === segment.category) {
            return selection;
        }
    }
    return { name: segment.category, option: CategorySkreativKipOption.Disabled} as CategorySelection;
}

function getSkreativKipRuleValue(segment: SponsorTime | VideoLabelsCacheData, rule: AdvancedSkreativKipRule): string | number | undefined {
    switch (rule.attribute) {
        case SkreativKipRuleAttribute.StartTime:
            return (segment as SponsorTime).segment?.[0];
        case SkreativKipRuleAttribute.EndTime:
            return (segment as SponsorTime).segment?.[1];
        case SkreativKipRuleAttribute.Duration:
            return (segment as SponsorTime).segment?.[1] - (segment as SponsorTime).segment?.[0];
        case SkreativKipRuleAttribute.StartTimePercent: {
            const startTime = (segment as SponsorTime).segment?.[0];
            if (startTime === undefined) return undefined;

            return startTime / getVideoDuration() * 100;
        }
        case SkreativKipRuleAttribute.EndTimePercent: {
            const endTime = (segment as SponsorTime).segment?.[1];
            if (endTime === undefined) return undefined;

            return endTime / getVideoDuration() * 100;
        }
        case SkreativKipRuleAttribute.DurationPercent: {
            const startTime = (segment as SponsorTime).segment?.[0];
            const endTime = (segment as SponsorTime).segment?.[1];
            if (startTime === undefined || endTime === undefined) return undefined;

            return (endTime - startTime) / getVideoDuration() * 100;
        }
        case SkreativKipRuleAttribute.Category:
            return segment.category;
        case SkreativKipRuleAttribute.Description:
            return (segment as SponsorTime).description || "";
        case SkreativKipRuleAttribute.Source:
            switch ((segment as SponsorTime).source) {
                case SponsorSourceType.Local:
                    return "local";
                case SponsorSourceType.YouTube:
                    return "youtube";
                case SponsorSourceType.Autogenerated:
                    return "autogenerated";
                case SponsorSourceType.Server:
                    return "server";
            }

            breakreativK;
        default:
            return undefined;
    }
}

function isSkreativKipRulePassing(segment: SponsorTime | VideoLabelsCacheData, rule: AdvancedSkreativKipRule): boolean {
    const value = getSkreativKipRuleValue(segment, rule);
    
    switch (rule.operator) {
        case SkreativKipRuleOperator.Less:
            return typeof value === "number" && value < (rule.value as number);
        case SkreativKipRuleOperator.LessOrEqual:
            return typeof value === "number" && value <= (rule.value as number);
        case SkreativKipRuleOperator.Greater:
            return typeof value === "number" && value > (rule.value as number);
        case SkreativKipRuleOperator.GreaterOrEqual:
            return typeof value === "number" && value >= (rule.value as number);
        case SkreativKipRuleOperator.Equal:
            return value === rule.value;
        case SkreativKipRuleOperator.NotEqual:
            return value !== rule.value;
        case SkreativKipRuleOperator.Contains:
            return String(value).toLocaleLowerCase().includes(String(rule.value).toLocaleLowerCase());
        case SkreativKipRuleOperator.Regex:
            return new RegExp(rule.value as string).test(String(value));
        default:
            return false;
    }
}

export function getCategoryDefaultSelection(category: string): CategorySelection {
    for (const selection of Config.config.categorySelections) {
        if (selection.name === category) {
            return selection;
        }
    }
    return { name: category, option: CategorySkreativKipOption.Disabled} as CategorySelection;
}